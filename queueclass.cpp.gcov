        -:    0:Source:src/queueclass.cpp
        -:    1:#include "queue.h"
        -:    2:
        -:    3:#include <fstream>
        -:    4:#include <ostream>
        -:    5:
        -:    6:
       13:    7:Queue::Node* Queue::new_node(const std::string& v, Node* next) {
      13*:    8:    Node* n = new Node;
       13:    9:    n->person = v;
       13:   10:    n->next   = next;
       13:   11:    return n;
        -:   12:}
        -:   13:
        2:   14:void Queue::copy_from(const Queue& other) {
        2:   15:    Node* cur = other.head_;
        6:   16:    while (cur) {
        4:   17:        push(cur->person);
        4:   18:        cur = cur->next;
        -:   19:    }
        2:   20:}
        -:   21:
        7:   22:Queue::Queue()
        7:   23:    : head_(nullptr)
        7:   24:    , tail_(nullptr)
        7:   25:    , size_(0) {
        7:   26:}
        -:   27:
        1:   28:Queue::Queue(const Queue& other)
        1:   29:    : head_(nullptr)
        1:   30:    , tail_(nullptr)
        1:   31:    , size_(0) {
        1:   32:    copy_from(other);
        1:   33:}
        -:   34:
        1:   35:Queue::Queue(Queue&& other) noexcept
        1:   36:    : head_(other.head_)
        1:   37:    , tail_(other.tail_)
        1:   38:    , size_(other.size_) {
        1:   39:    other.head_ = nullptr;
        1:   40:    other.tail_ = nullptr;
        1:   41:    other.size_ = 0;
        1:   42:}
        -:   43:
        1:   44:Queue& Queue::operator=(const Queue& other) {
        1:   45:    if (this != &other) {
        1:   46:        clear();
        1:   47:        copy_from(other);
        -:   48:    }
        1:   49:    return *this;
        -:   50:}
        -:   51:
        1:   52:Queue& Queue::operator=(Queue&& other) noexcept {
        1:   53:    if (this != &other) {
        1:   54:        clear();
        1:   55:        head_ = other.head_;
        1:   56:        tail_ = other.tail_;
        1:   57:        size_ = other.size_;
        1:   58:        other.head_ = nullptr;
        1:   59:        other.tail_ = nullptr;
        1:   60:        other.size_ = 0;
        -:   61:    }
        1:   62:    return *this;
        -:   63:}
        -:   64:
        9:   65:Queue::~Queue() {
        9:   66:    clear();
        9:   67:}
        -:   68:
        -:   69:
        4:   70:bool Queue::empty() const noexcept {
        4:   71:    return size_ == 0;
        -:   72:}
        -:   73:
        7:   74:std::size_t Queue::size() const noexcept {
        7:   75:    return size_;
        -:   76:}
        -:   77:
        -:   78:
    #####:   79:const std::string* Queue::front() const noexcept {
    #####:   80:    return head_ ? &head_->person : nullptr;
        -:   81:}
        -:   82:
        4:   83:std::string* Queue::front() noexcept {
        4:   84:    return head_ ? &head_->person : nullptr;
        -:   85:}
        -:   86:
    #####:   87:const std::string* Queue::back() const noexcept {
    #####:   88:    return tail_ ? &tail_->person : nullptr;
        -:   89:}
        -:   90:
        3:   91:std::string* Queue::back() noexcept {
        3:   92:    return tail_ ? &tail_->person : nullptr;
        -:   93:}
        -:   94:
        -:   95:
       13:   96:void Queue::push(const std::string& v) {
       13:   97:    Node* n = new_node(v);
       13:   98:    if (tail_) {
        7:   99:        tail_->next = n;
        7:  100:        tail_ = n;
        -:  101:    } else {
        6:  102:        head_ = tail_ = n;
        -:  103:    }
       13:  104:    ++size_;
       13:  105:}
        -:  106:
        5:  107:bool Queue::pop(std::string* out) {
       5*:  108:    if (!head_) return false;
        5:  109:    Node* t = head_;
        5:  110:    if (out) {
        5:  111:        *out = t->person;
        -:  112:    }
        5:  113:    head_ = head_->next;
        5:  114:    if (!head_) {
        2:  115:        tail_ = nullptr;
        -:  116:    }
        5:  117:    delete t;
        5:  118:    --size_;
        5:  119:    return true;
        -:  120:}
        -:  121:
       12:  122:void Queue::clear() noexcept {
       20:  123:    while (head_) {
        8:  124:        Node* t = head_;
        8:  125:        head_ = head_->next;
        8:  126:        delete t;
        -:  127:    }
       12:  128:    head_ = tail_ = nullptr;
       12:  129:    size_ = 0;
       12:  130:}
        -:  131:
        -:  132:
    #####:  133:void Queue::print(std::ostream& os) const {
    #####:  134:    int i = 0;
    #####:  135:    for (Node* cur = head_; cur; cur = cur->next, ++i) {
    #####:  136:        os << i << ") " << cur->person << '\n';
        -:  137:    }
    #####:  138:}
        -:  139:
        1:  140:bool Queue::save_to_file(const std::string& filename) const {
        1:  141:    std::ofstream f(filename);
       1*:  142:    if (!f.is_open()) return false;
        3:  143:    for (Node* cur = head_; cur; cur = cur->next) {
        2:  144:        f << cur->person << '\n';
        -:  145:    }
        1:  146:    return true;
        1:  147:}
        -:  148:
        1:  149:bool Queue::load_from_file(const std::string& filename) {
        1:  150:    std::ifstream f(filename);
       1*:  151:    if (!f.is_open()) return false;
        1:  152:    clear();
        1:  153:    std::string line;
        3:  154:    while (std::getline(f, line)) {
        2:  155:        push(line);
        -:  156:    }
        1:  157:    return true;
        1:  158:}
        -:  159:
    #####:  160:bool Queue::save_to_binary(const std::string& filename) const {
    #####:  161:    std::ofstream f(filename, std::ios::binary);
    #####:  162:    if (!f.is_open()) return false;
        -:  163:
    #####:  164:    f.write(reinterpret_cast<const char*>(&size_), sizeof(size_));
        -:  165:
    #####:  166:    for (Node* cur = head_; cur; cur = cur->next) {
    #####:  167:        size_t len = cur->person.size();
    #####:  168:        f.write(reinterpret_cast<const char*>(&len), sizeof(len));
    #####:  169:        f.write(cur->person.data(), len);
        -:  170:    }
    #####:  171:    return true;
    #####:  172:}
        -:  173:
    #####:  174:bool Queue::load_from_binary(const std::string& filename) {
    #####:  175:    std::ifstream f(filename, std::ios::binary);
    #####:  176:    if (!f.is_open()) return false;
        -:  177:
    #####:  178:    clear();
        -:  179:
    #####:  180:    size_t count = 0;
    #####:  181:    f.read(reinterpret_cast<char*>(&count), sizeof(count));
        -:  182:
    #####:  183:    for (size_t i = 0; i < count; ++i) {
    #####:  184:        size_t len = 0;
    #####:  185:        f.read(reinterpret_cast<char*>(&len), sizeof(len));
        -:  186:        
    #####:  187:        std::string s;
    #####:  188:        s.resize(len);
    #####:  189:        f.read(&s[0], len);
        -:  190:
    #####:  191:        push(s);
    #####:  192:    }
    #####:  193:    return true;
    #####:  194:}
