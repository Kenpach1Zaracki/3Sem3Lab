        -:    0:Source:src/stackclass.cpp
        -:    1:#include "stack.h"
        -:    2:
        -:    3:#include <fstream>
        -:    4:#include <ostream>
        -:    5:#include <vector>
        -:    6:
        -:    7:
        -:    8:
       13:    9:Stack::Node* Stack::new_node(const std::string& v, Node* next) {
      13*:   10:    Node* n = new Node;
       13:   11:    n->person = v;
       13:   12:    n->next   = next;
       13:   13:    return n;
        -:   14:}
        -:   15:
        -:   16:// аккуратное копирование с сохранением порядка (низ -> верх такой же)
        2:   17:void Stack::copy_from(const Stack& other) {
        -:   18:    // other.top_ -> низ: собираем во временный вектор
        2:   19:    std::vector<std::string> buf;
        6:   20:    for (Node* p = other.top_; p; p = p->next) {
        4:   21:        buf.push_back(p->person);
        -:   22:    }
        -:   23:    // в buf[0] — вершина other, в buf[last] — низ
        6:   24:    for (auto it = buf.rbegin(); it != buf.rend(); ++it) {
        4:   25:        push(*it);
        -:   26:    }
        2:   27:}
        -:   28:
        -:   29:
        7:   30:Stack::Stack()
        7:   31:    : top_(nullptr)
        7:   32:    , size_(0) {
        7:   33:}
        -:   34:
        1:   35:Stack::Stack(const Stack& other)
        1:   36:    : top_(nullptr)
        1:   37:    , size_(0) {
        1:   38:    copy_from(other);
        1:   39:}
        -:   40:
        1:   41:Stack::Stack(Stack&& other) noexcept
        1:   42:    : top_(other.top_)
        1:   43:    , size_(other.size_) {
        1:   44:    other.top_ = nullptr;
        1:   45:    other.size_ = 0;
        1:   46:}
        -:   47:
        1:   48:Stack& Stack::operator=(const Stack& other) {
        1:   49:    if (this != &other) {
        1:   50:        clear();
        1:   51:        copy_from(other);
        -:   52:    }
        1:   53:    return *this;
        -:   54:}
        -:   55:
        1:   56:Stack& Stack::operator=(Stack&& other) noexcept {
        1:   57:    if (this != &other) {
        1:   58:        clear();
        1:   59:        top_ = other.top_;
        1:   60:        size_ = other.size_;
        1:   61:        other.top_ = nullptr;
        1:   62:        other.size_ = 0;
        -:   63:    }
        1:   64:    return *this;
        -:   65:}
        -:   66:
        9:   67:Stack::~Stack() {
        9:   68:    clear();
        9:   69:}
        -:   70:
        4:   71:bool Stack::empty() const noexcept {
        4:   72:    return size_ == 0;
        -:   73:}
        -:   74:
        7:   75:std::size_t Stack::size() const noexcept {
        7:   76:    return size_;
        -:   77:}
        -:   78:
    #####:   79:const std::string* Stack::peek() const noexcept {
    #####:   80:    return top_ ? &top_->person : nullptr;
        -:   81:}
        -:   82:
        5:   83:std::string* Stack::peek() noexcept {
        5:   84:    return top_ ? &top_->person : nullptr;
        -:   85:}
        -:   86:
        -:   87:
       13:   88:void Stack::push(const std::string& v) {
       13:   89:    Node* n = new_node(v, top_);
       13:   90:    top_ = n;
       13:   91:    ++size_;
       13:   92:}
        -:   93:
        4:   94:bool Stack::pop(std::string* out) {
        4:   95:    if (!top_) return false;
        3:   96:    Node* t = top_;
        3:   97:    if (out) {
        3:   98:        *out = t->person;
        -:   99:    }
        3:  100:    top_ = top_->next;
        3:  101:    delete t;
        3:  102:    --size_;
        3:  103:    return true;
        -:  104:}
        -:  105:
       12:  106:void Stack::clear() noexcept {
       22:  107:    while (top_) {
       10:  108:        Node* t = top_;
       10:  109:        top_ = top_->next;
       10:  110:        delete t;
        -:  111:    }
       12:  112:    size_ = 0;
       12:  113:}
        -:  114:
        -:  115:
    #####:  116:void Stack::print(std::ostream& os) const {
    #####:  117:    int i = 0;
    #####:  118:    for (Node* p = top_; p; p = p->next, ++i) {
    #####:  119:        os << i << ") " << p->person << '\n';
        -:  120:    }
    #####:  121:}
        -:  122:
        -:  123:// сохраняем элементы в порядке "низ -> верх"
        1:  124:bool Stack::save_to_file(const std::string& filename) const {
        1:  125:    std::ofstream f(filename);
       1*:  126:    if (!f.is_open()) return false;
        -:  127:
        1:  128:    std::vector<std::string> buf;
        3:  129:    for (Node* p = top_; p; p = p->next) {
        2:  130:        buf.push_back(p->person);
        -:  131:    }
        -:  132:    // в buf[0] — вершина, в buf[last] — низ
        -:  133:    // пишем в файл в обратном порядке: низ -> верх
        3:  134:    for (int i = static_cast<int>(buf.size()) - 1; i >= 0; --i) {
        2:  135:        f << buf[static_cast<std::size_t>(i)] << '\n';
        -:  136:    }
        1:  137:    return true;
        1:  138:}
        -:  139:
    #####:  140:bool Stack::save_to_binary(const std::string& filename) const {
    #####:  141:    std::ofstream f(filename, std::ios::binary);
    #####:  142:    if (!f.is_open()) return false;
        -:  143:
    #####:  144:    f.write(reinterpret_cast<const char*>(&size_), sizeof(size_));
        -:  145:
    #####:  146:    std::vector<std::string> buf;
    #####:  147:    for (Node* p = top_; p; p = p->next) {
    #####:  148:        buf.push_back(p->person);
        -:  149:    }
        -:  150:    // buf[0] is top, buf[last] is bottom.
        -:  151:    // We want to save bottom -> top.
    #####:  152:    for (int i = static_cast<int>(buf.size()) - 1; i >= 0; --i) {
    #####:  153:        const std::string& s = buf[static_cast<std::size_t>(i)];
    #####:  154:        size_t len = s.size();
    #####:  155:        f.write(reinterpret_cast<const char*>(&len), sizeof(len));
    #####:  156:        f.write(s.data(), len);
        -:  157:    }
    #####:  158:    return true;
    #####:  159:}
        -:  160:
        -:  161:
        -:  162:// читаем файл строками и пушим в стек по очереди
        -:  163:// (при условии, что файл был сохранён save_to_file, порядок восстановится)
        1:  164:bool Stack::load_from_file(const std::string& filename) {
        1:  165:    std::ifstream f(filename);
       1*:  166:    if (!f.is_open()) return false;
        -:  167:
        1:  168:    clear();
        1:  169:    std::string s;
        3:  170:    while (std::getline(f, s)) {
        -:  171:        // читаем низ->верх и пушим в таком порядке
        2:  172:        push(s);
        -:  173:    }
        1:  174:    return true;
        1:  175:}
        -:  176:
    #####:  177:bool Stack::load_from_binary(const std::string& filename) {
    #####:  178:    std::ifstream f(filename, std::ios::binary);
    #####:  179:    if (!f.is_open()) return false;
        -:  180:
    #####:  181:    clear();
        -:  182:
    #####:  183:    size_t count = 0;
    #####:  184:    f.read(reinterpret_cast<char*>(&count), sizeof(count));
        -:  185:
    #####:  186:    for (size_t i = 0; i < count; ++i) {
    #####:  187:        size_t len = 0;
    #####:  188:        f.read(reinterpret_cast<char*>(&len), sizeof(len));
        -:  189:        
    #####:  190:        std::string s;
    #####:  191:        s.resize(len);
    #####:  192:        f.read(&s[0], len);
        -:  193:
    #####:  194:        push(s);
    #####:  195:    }
    #####:  196:    return true;
    #####:  197:}
