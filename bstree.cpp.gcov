        -:    0:Source:src/bstree.cpp
        -:    1:#include "bstree.h"
        -:    2:
        -:    3:#include <fstream>
        -:    4:#include <functional>
        -:    5:#include <ostream>
        -:    6:
        -:    7:
       16:    8:BSTree::Node* BSTree::new_node(const std::string& v) {
      16*:    9:    Node* n = new Node;
       16:   10:    n->value = v;
       16:   11:    n->left  = nullptr;
       16:   12:    n->right = nullptr;
       16:   13:    return n;
        -:   14:}
        -:   15:
       51:   16:void BSTree::delete_subtree(Node* node) {
       51:   17:    if (!node) return;
       19:   18:    delete_subtree(node->left);
       19:   19:    delete_subtree(node->right);
       19:   20:    delete node;
        -:   21:}
        -:   22:
       14:   23:BSTree::Node* BSTree::copy_subtree(const Node* node) {
       14:   24:    if (!node) return nullptr;
       6*:   25:    Node* n = new Node;
        6:   26:    n->value = node->value;
        6:   27:    n->left  = copy_subtree(node->left);
        6:   28:    n->right = copy_subtree(node->right);
        6:   29:    return n;
        -:   30:}
        -:   31:
       29:   32:std::size_t BSTree::calc_size(const Node* node) {
       29:   33:    if (!node) return 0;
       12:   34:    return 1 + calc_size(node->left) + calc_size(node->right);
        -:   35:}
        -:   36:
        8:   37:int BSTree::calc_height(const Node* node) {
        8:   38:    if (!node) return 0;
        3:   39:    int hl = calc_height(node->left);
        3:   40:    int hr = calc_height(node->right);
       3*:   41:    return 1 + (hl > hr ? hl : hr);
        -:   42:}
        -:   43:
        -:   44:// вставка: возвращает true, если реально добавили новый узел
       30:   45:bool BSTree::insert_rec(Node*& node, const std::string& value) {
       30:   46:    if (!node) {
       16:   47:        node = new_node(value);
       16:   48:        return true;
        -:   49:    }
       14:   50:    if (value < node->value) {
        4:   51:        return insert_rec(node->left, value);
       10:   52:    } else if (value > node->value) {
        9:   53:        return insert_rec(node->right, value);
        -:   54:    } else {
        -:   55:        // уже есть
        1:   56:        return false;
        -:   57:    }
        -:   58:}
        -:   59:
       26:   60:bool BSTree::contains_rec(const Node* node, const std::string& value) {
       26:   61:    if (!node) return false;
       22:   62:    if (value < node->value) {
        1:   63:        return contains_rec(node->left, value);
       21:   64:    } else if (value > node->value) {
       11:   65:        return contains_rec(node->right, value);
        -:   66:    } else {
       10:   67:        return true;
        -:   68:    }
        -:   69:}
        -:   70:
        -:   71:// поиск минимального узла в поддереве
        2:   72:BSTree::Node* BSTree::find_min_node(Node* node) {
        2:   73:    if (!node) return nullptr;
        2:   74:    while (node->left) node = node->left;
        1:   75:    return node;
        -:   76:}
    #####:   77:const BSTree::Node* BSTree::find_min_node(const Node* node) {
    #####:   78:    if (!node) return nullptr;
    #####:   79:    while (node->left) node = node->left;
    #####:   80:    return node;
        -:   81:}
        2:   82:const BSTree::Node* BSTree::find_max_node(const Node* node) {
        2:   83:    if (!node) return nullptr;
        2:   84:    while (node->right) node = node->right;
        1:   85:    return node;
        -:   86:}
        -:   87:
        -:   88:// удаление узла по значению
        6:   89:bool BSTree::erase_rec(Node*& node, const std::string& value) {
       6*:   90:    if (!node) return false;
        -:   91:
        6:   92:    if (value < node->value) {
    #####:   93:        return erase_rec(node->left, value);
        6:   94:    } else if (value > node->value) {
        3:   95:        return erase_rec(node->right, value);
        -:   96:    } else {
        -:   97:        // нашли
        -:   98:        // 1) нет детей
        3:   99:        if (!node->left && !node->right) {
        2:  100:            delete node;
        2:  101:            node = nullptr;
        -:  102:        }
        -:  103:        // 2) только правый
        1:  104:        else if (!node->left) {
    #####:  105:            Node* tmp = node;
    #####:  106:            node = node->right;
    #####:  107:            delete tmp;
        -:  108:        }
        -:  109:        // 3) только левый
        1:  110:        else if (!node->right) {
        1:  111:            Node* tmp = node;
        1:  112:            node = node->left;
        1:  113:            delete tmp;
        -:  114:        }
        -:  115:        // 4) два ребёнка: берём минимальный элемент из правого поддерева
        -:  116:        else {
    #####:  117:            Node* minRight = find_min_node(node->right);
    #####:  118:            node->value = minRight->value;               // копируем значение
    #####:  119:            erase_rec(node->right, minRight->value);     // удаляем дубль ниже
        -:  120:        }
        3:  121:        return true;
        -:  122:    }
        -:  123:}
        -:  124:
        7:  125:void BSTree::print_inorder_rec(const Node* node, std::ostream& os) {
        7:  126:    if (!node) return;
        3:  127:    print_inorder_rec(node->left, os);
        3:  128:    os << node->value << '\n';
        3:  129:    print_inorder_rec(node->right, os);
        -:  130:}
        -:  131:
    #####:  132:void BSTree::print_structure_rec(const Node* node, std::ostream& os, int depth) {
    #####:  133:    if (!node) return;
    #####:  134:    for (int i = 0; i < depth; ++i) os << "  ";
    #####:  135:    os << node->value << '\n';
    #####:  136:    print_structure_rec(node->left, os, depth + 1);
    #####:  137:    print_structure_rec(node->right, os, depth + 1);
        -:  138:}
        -:  139:
        -:  140:
        8:  141:BSTree::BSTree()
        8:  142:    : root_(nullptr)
        8:  143:    , size_(0) {
        8:  144:}
        -:  145:
        1:  146:BSTree::BSTree(const BSTree& other)
        1:  147:    : root_(nullptr)
        1:  148:    , size_(0) {
        1:  149:    root_ = copy_subtree(other.root_);
        1:  150:    size_ = calc_size(root_);
        1:  151:}
        -:  152:
        1:  153:BSTree::BSTree(BSTree&& other) noexcept
        1:  154:    : root_(other.root_)
        1:  155:    , size_(other.size_) {
        1:  156:    other.root_ = nullptr;
        1:  157:    other.size_ = 0;
        1:  158:}
        -:  159:
        1:  160:BSTree& BSTree::operator=(const BSTree& other) {
        1:  161:    if (this != &other) {
        1:  162:        clear();
        1:  163:        root_ = copy_subtree(other.root_);
        1:  164:        size_ = calc_size(root_);
        -:  165:    }
        1:  166:    return *this;
        -:  167:}
        -:  168:
        1:  169:BSTree& BSTree::operator=(BSTree&& other) noexcept {
        1:  170:    if (this != &other) {
        1:  171:        clear();
        1:  172:        root_ = other.root_;
        1:  173:        size_ = other.size_;
        1:  174:        other.root_ = nullptr;
        1:  175:        other.size_ = 0;
        -:  176:    }
        1:  177:    return *this;
        -:  178:}
        -:  179:
       10:  180:BSTree::~BSTree() {
       10:  181:    clear();
       10:  182:}
        -:  183:
        -:  184:
        3:  185:bool BSTree::empty() const noexcept {
        3:  186:    return size_ == 0;
        -:  187:}
        -:  188:
        7:  189:std::size_t BSTree::size() const noexcept {
        7:  190:    return size_;
        -:  191:}
        -:  192:
        2:  193:int BSTree::height() const noexcept {
        2:  194:    return calc_height(root_);
        -:  195:}
        -:  196:
        -:  197:
       17:  198:bool BSTree::insert(const std::string& value) {
       17:  199:    bool added = insert_rec(root_, value);
       17:  200:    if (added) ++size_;
       17:  201:    return added;
        -:  202:}
        -:  203:
       14:  204:bool BSTree::contains(const std::string& value) const {
       14:  205:    return contains_rec(root_, value);
        -:  206:}
        -:  207:
        3:  208:bool BSTree::erase(const std::string& value) {
        3:  209:    bool removed = erase_rec(root_, value);
        3:  210:    if (removed) {
        3:  211:        size_ = calc_size(root_);
        -:  212:    }
        3:  213:    return removed;
        -:  214:}
        -:  215:
        2:  216:const std::string* BSTree::min_value() const {
        2:  217:    const Node* n = find_min_node(root_);
        2:  218:    return n ? &n->value : nullptr;
        -:  219:}
        -:  220:
        2:  221:const std::string* BSTree::max_value() const {
        2:  222:    const Node* n = find_max_node(root_);
        2:  223:    return n ? &n->value : nullptr;
        -:  224:}
        -:  225:
       13:  226:void BSTree::clear() noexcept {
       13:  227:    delete_subtree(root_);
       13:  228:    root_ = nullptr;
       13:  229:    size_ = 0;
       13:  230:}
        -:  231:
        -:  232:
    #####:  233:void BSTree::print_inorder(std::ostream& os) const {
    #####:  234:    print_inorder_rec(root_, os);
    #####:  235:}
        -:  236:
    #####:  237:void BSTree::print_structure(std::ostream& os) const {
    #####:  238:    print_structure_rec(root_, os, 0);
    #####:  239:}
        -:  240:
        1:  241:bool BSTree::save_to_file(const std::string& filename) const {
        1:  242:    std::ofstream f(filename);
       1*:  243:    if (!f.is_open()) return false;
        1:  244:    print_inorder_rec(root_, f);
        1:  245:    return true;
        1:  246:}
        -:  247:
        1:  248:bool BSTree::load_from_file(const std::string& filename) {
        1:  249:    std::ifstream f(filename);
       1*:  250:    if (!f.is_open()) return false;
        1:  251:    clear();
        1:  252:    std::string line;
        4:  253:    while (std::getline(f, line)) {
        3:  254:        if (!line.empty())
        3:  255:            insert(line);
        -:  256:    }
        1:  257:    return true;
        1:  258:}
        -:  259:
    #####:  260:bool BSTree::save_to_binary(const std::string& filename) const {
    #####:  261:    std::ofstream f(filename, std::ios::binary);
    #####:  262:    if (!f.is_open()) return false;
        -:  263:
        -:  264:    // Write size
    #####:  265:    f.write(reinterpret_cast<const char*>(&size_), sizeof(size_));
        -:  266:
        -:  267:    // Helper to write string
    #####:  268:    auto write_str = [&](const std::string& s) {
    #####:  269:        size_t len = s.size();
    #####:  270:        f.write(reinterpret_cast<const char*>(&len), sizeof(len));
    #####:  271:        f.write(s.data(), len);
    #####:  272:    };
        -:  273:
        -:  274:    // Pre-order traversal to preserve structure when inserting back
    #####:  275:    std::function<void(const Node*)> save_rec = [&](const Node* node) {
    #####:  276:        if (!node) return;
    #####:  277:        write_str(node->value);
    #####:  278:        save_rec(node->left);
    #####:  279:        save_rec(node->right);
    #####:  280:    };
        -:  281:
    #####:  282:    save_rec(root_);
    #####:  283:    return true;
    #####:  284:}
        -:  285:
    #####:  286:bool BSTree::load_from_binary(const std::string& filename) {
    #####:  287:    std::ifstream f(filename, std::ios::binary);
    #####:  288:    if (!f.is_open()) return false;
        -:  289:
    #####:  290:    clear();
        -:  291:
    #####:  292:    size_t count = 0;
    #####:  293:    f.read(reinterpret_cast<char*>(&count), sizeof(count));
        -:  294:
    #####:  295:    for (size_t i = 0; i < count; ++i) {
    #####:  296:        size_t len = 0;
    #####:  297:        f.read(reinterpret_cast<char*>(&len), sizeof(len));
        -:  298:        
    #####:  299:        std::string s;
    #####:  300:        s.resize(len);
    #####:  301:        f.read(&s[0], len);
        -:  302:
    #####:  303:        insert(s);
    #####:  304:    }
    #####:  305:    return true;
    #####:  306:}
