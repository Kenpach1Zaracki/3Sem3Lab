        -:    0:Source:src/hashclass.cpp
        -:    1:#include "hash.h"
        -:    2:
        -:    3:#include <fstream>
        -:    4:#include <ostream>
        -:    5:
       23:    6:std::size_t HashMap::hash_str(const std::string& s, std::size_t bucketCount) {
       23:    7:    unsigned int h = 0;
       75:    8:    for (char c : s) {
       29:    9:        h = h * 131u + static_cast<unsigned char>(c);
        -:   10:    }
       23:   11:    return static_cast<std::size_t>(h % static_cast<unsigned int>(bucketCount));
        -:   12:}
       10:   13:void HashMap::init_buckets(std::size_t bucketCount) {
       10:   14:    bucketCount_ = bucketCount;
       10:   15:    size_ = 0;
      10*:   16:    buckets_ = new Node*[bucketCount_];
    10250:   17:    for (std::size_t i = 0; i < bucketCount_; ++i) {
    10240:   18:        buckets_[i] = nullptr;
        -:   19:    }
       10:   20:}
        -:   21:
       11:   22:void HashMap::free_buckets() noexcept {
       11:   23:    if (!buckets_) return;
    10250:   24:    for (std::size_t i = 0; i < bucketCount_; ++i) {
    10240:   25:        Node* cur = buckets_[i];
    10251:   26:        while (cur) {
       11:   27:            Node* next = cur->next;
       11:   28:            delete cur;
       11:   29:            cur = next;
        -:   30:        }
    10240:   31:        buckets_[i] = nullptr;
        -:   32:    }
       10:   33:    delete[] buckets_;
       10:   34:    buckets_ = nullptr;
       10:   35:    bucketCount_ = 0;
       10:   36:    size_ = 0;
        -:   37:}
        -:   38:
        2:   39:void HashMap::copy_from(const HashMap& other) {
        2:   40:    init_buckets(other.bucketCount_);
     2050:   41:    for (std::size_t i = 0; i < other.bucketCount_; ++i) {
     2048:   42:        Node* src = other.buckets_[i];
     2048:   43:        Node* prevNew = nullptr;
     2052:   44:        while (src) {
       4*:   45:            Node* n = new Node{src->key, src->value, nullptr};
        4:   46:            if (!buckets_[i]) {
        4:   47:                buckets_[i] = n;
        -:   48:            } else {
    #####:   49:                prevNew->next = n;
        -:   50:            }
        4:   51:            prevNew = n;
        4:   52:            src = src->next;
        4:   53:            ++size_;
        -:   54:        }
        -:   55:    }
        2:   56:}
        -:   57:
        6:   58:HashMap::HashMap(std::size_t bucketCount)
        6:   59:    : buckets_(nullptr)
        6:   60:    , bucketCount_(0)
        6:   61:    , size_(0) {
       6*:   62:    if (bucketCount == 0) bucketCount = 1;
        6:   63:    init_buckets(bucketCount);
        6:   64:}
        -:   65:
        1:   66:HashMap::HashMap(const HashMap& other)
        1:   67:    : buckets_(nullptr)
        1:   68:    , bucketCount_(0)
        1:   69:    , size_(0) {
        1:   70:    copy_from(other);
        1:   71:}
        -:   72:
        1:   73:HashMap::HashMap(HashMap&& other) noexcept
        1:   74:    : buckets_(other.buckets_)
        1:   75:    , bucketCount_(other.bucketCount_)
        1:   76:    , size_(other.size_) {
        1:   77:    other.buckets_ = nullptr;
        1:   78:    other.bucketCount_ = 0;
        1:   79:    other.size_ = 0;
        1:   80:}
        -:   81:
        1:   82:HashMap& HashMap::operator=(const HashMap& other) {
        1:   83:    if (this != &other) {
        1:   84:        free_buckets();
        1:   85:        copy_from(other);
        -:   86:    }
        1:   87:    return *this;
        -:   88:}
        -:   89:
    #####:   90:HashMap& HashMap::operator=(HashMap&& other) noexcept {
    #####:   91:    if (this != &other) {
    #####:   92:        free_buckets();
    #####:   93:        buckets_ = other.buckets_;
    #####:   94:        bucketCount_ = other.bucketCount_;
    #####:   95:        size_ = other.size_;
    #####:   96:        other.buckets_ = nullptr;
    #####:   97:        other.bucketCount_ = 0;
    #####:   98:        other.size_ = 0;
        -:   99:    }
    #####:  100:    return *this;
        -:  101:}
        -:  102:
        8:  103:HashMap::~HashMap() {
        8:  104:    free_buckets();
        8:  105:}
        -:  106:
        2:  107:bool HashMap::empty() const noexcept {
        2:  108:    return size_ == 0;
        -:  109:}
        -:  110:
        5:  111:std::size_t HashMap::size() const noexcept {
        5:  112:    return size_;
        -:  113:}
        -:  114:
        1:  115:std::size_t HashMap::bucket_count() const noexcept {
        1:  116:    return bucketCount_;
        -:  117:}
        -:  118:
        -:  119:
        7:  120:bool HashMap::contains(const std::string& key) const {
       7*:  121:    if (!buckets_ || bucketCount_ == 0) return false;
        7:  122:    std::size_t idx = hash_str(key, bucketCount_);
        7:  123:    Node* cur = buckets_[idx];
        7:  124:    while (cur) {
        5:  125:        if (cur->key == key) return true;
    #####:  126:        cur = cur->next;
        -:  127:    }
        2:  128:    return false;
        -:  129:}
        -:  130:
        9:  131:void HashMap::set(const std::string& key, const std::string& val) {
       9*:  132:    if (!buckets_ || bucketCount_ == 0) return;
        -:  133:
        9:  134:    std::size_t idx = hash_str(key, bucketCount_);
        9:  135:    Node* cur = buckets_[idx];
        -:  136:
        -:  137:    // если нашли ключ — обновляем значение
        9:  138:    while (cur) {
        1:  139:        if (cur->key == key) {
        1:  140:            cur->value = val;
        1:  141:            return;
        -:  142:        }
    #####:  143:        cur = cur->next;
        -:  144:    }
        -:  145:
        -:  146:    // не нашли — вставляем новый в голову цепочки
       8*:  147:    Node* node = new Node{key, val, buckets_[idx]};
        8:  148:    buckets_[idx] = node;
        8:  149:    ++size_;
        -:  150:}
        -:  151:
        5:  152:bool HashMap::get(const std::string& key, std::string& outVal) const {
       5*:  153:    if (!buckets_ || bucketCount_ == 0) return false;
        5:  154:    std::size_t idx = hash_str(key, bucketCount_);
        5:  155:    Node* cur = buckets_[idx];
        5:  156:    while (cur) {
        4:  157:        if (cur->key == key) {
        4:  158:            outVal = cur->value;
        4:  159:            return true;
        -:  160:        }
    #####:  161:        cur = cur->next;
        -:  162:    }
        1:  163:    return false;
        -:  164:}
        -:  165:
        2:  166:bool HashMap::erase(const std::string& key) {
       2*:  167:    if (!buckets_ || bucketCount_ == 0) return false;
        2:  168:    std::size_t idx = hash_str(key, bucketCount_);
        2:  169:    Node* cur = buckets_[idx];
        2:  170:    Node* prev = nullptr;
        -:  171:
        2:  172:    while (cur) {
        1:  173:        if (cur->key == key) {
        1:  174:            if (prev) {
    #####:  175:                prev->next = cur->next;
        -:  176:            } else {
        1:  177:                buckets_[idx] = cur->next;
        -:  178:            }
        1:  179:            delete cur;
        1:  180:            --size_;
        1:  181:            return true;
        -:  182:        }
    #####:  183:        prev = cur;
    #####:  184:        cur = cur->next;
        -:  185:    }
        1:  186:    return false;
        -:  187:}
        -:  188:
        2:  189:void HashMap::clear() noexcept {
        2:  190:    free_buckets();
        2:  191:    if (bucketCount_ == 0) {
        2:  192:        init_buckets(1024); // чтобы не остаться с нулём
        -:  193:    } else {
    #####:  194:        init_buckets(bucketCount_);
        -:  195:    }
        2:  196:}
        -:  197:
        -:  198:
    #####:  199:void HashMap::print(std::ostream& os) const {
    #####:  200:    for (std::size_t i = 0; i < bucketCount_; ++i) {
    #####:  201:        Node* cur = buckets_[i];
    #####:  202:        while (cur) {
    #####:  203:            os << cur->key << " => " << cur->value << '\n';
    #####:  204:            cur = cur->next;
        -:  205:        }
        -:  206:    }
    #####:  207:}
        -:  208:
        1:  209:bool HashMap::save_to_file(const std::string& filename) const {
        1:  210:    std::ofstream f(filename);
       1*:  211:    if (!f.is_open()) return false;
        -:  212:    // простой текстовый формат key value на строку
     1025:  213:    for (std::size_t i = 0; i < bucketCount_; ++i) {
     1024:  214:        Node* cur = buckets_[i];
     1026:  215:        while (cur) {
        2:  216:            f << cur->key << ' ' << cur->value << '\n';
        2:  217:            cur = cur->next;
        -:  218:        }
        -:  219:    }
        1:  220:    return true;
        1:  221:}
        -:  222:
        1:  223:bool HashMap::load_from_file(const std::string& filename) {
        1:  224:    std::ifstream f(filename);
       1*:  225:    if (!f.is_open()) return false;
        1:  226:    clear();
        1:  227:    std::string key, value;
        3:  228:    while (f >> key >> value) {
        2:  229:        set(key, value);
        -:  230:    }
        1:  231:    return true;
        1:  232:}
        -:  233:
    #####:  234:bool HashMap::save_to_binary(const std::string& filename) const {
    #####:  235:    std::ofstream f(filename, std::ios::binary);
    #####:  236:    if (!f.is_open()) return false;
        -:  237:
    #####:  238:    f.write(reinterpret_cast<const char*>(&size_), sizeof(size_));
        -:  239:
    #####:  240:    for (std::size_t i = 0; i < bucketCount_; ++i) {
    #####:  241:        Node* cur = buckets_[i];
    #####:  242:        while (cur) {
    #####:  243:            size_t klen = cur->key.size();
    #####:  244:            f.write(reinterpret_cast<const char*>(&klen), sizeof(klen));
    #####:  245:            f.write(cur->key.data(), klen);
        -:  246:
    #####:  247:            size_t vlen = cur->value.size();
    #####:  248:            f.write(reinterpret_cast<const char*>(&vlen), sizeof(vlen));
    #####:  249:            f.write(cur->value.data(), vlen);
        -:  250:
    #####:  251:            cur = cur->next;
        -:  252:        }
        -:  253:    }
    #####:  254:    return true;
    #####:  255:}
        -:  256:
    #####:  257:bool HashMap::load_from_binary(const std::string& filename) {
    #####:  258:    std::ifstream f(filename, std::ios::binary);
    #####:  259:    if (!f.is_open()) return false;
        -:  260:
    #####:  261:    clear();
        -:  262:
    #####:  263:    size_t count = 0;
    #####:  264:    f.read(reinterpret_cast<char*>(&count), sizeof(count));
        -:  265:
    #####:  266:    for (size_t i = 0; i < count; ++i) {
    #####:  267:        size_t klen = 0;
    #####:  268:        f.read(reinterpret_cast<char*>(&klen), sizeof(klen));
    #####:  269:        std::string key;
    #####:  270:        key.resize(klen);
    #####:  271:        f.read(&key[0], klen);
        -:  272:
    #####:  273:        size_t vlen = 0;
    #####:  274:        f.read(reinterpret_cast<char*>(&vlen), sizeof(vlen));
    #####:  275:        std::string val;
    #####:  276:        val.resize(vlen);
    #####:  277:        f.read(&val[0], vlen);
        -:  278:
    #####:  279:        set(key, val);
    #####:  280:    }
    #####:  281:    return true;
    #####:  282:}
