        -:    0:Source:src/twolinkedclass.cpp
        -:    1:#include "twolink.h"
        -:    2:
        -:    3:#include <fstream>
        -:    4:#include <ostream>
        -:    5:
        -:    6:
       20:    7:DLinkedList::Node* DLinkedList::new_node(const std::string& v, Node* p, Node* n) {
      20*:    8:    Node* node = new Node;
       20:    9:    node->person = v;
       20:   10:    node->prev   = p;
       20:   11:    node->next   = n;
       20:   12:    return node;
        -:   13:}
        -:   14:
        9:   15:DLinkedList::Node* DLinkedList::node_at(std::size_t index) const {
        9:   16:    Node* cur = head_;
       14:   17:    while (cur && index--) {
        5:   18:        cur = cur->next;
        -:   19:    }
        9:   20:    return cur;
        -:   21:}
        -:   22:
        2:   23:void DLinkedList::copy_from(const DLinkedList& other) {
        2:   24:    Node* cur = other.head_;
        6:   25:    while (cur) {
        4:   26:        push_back(cur->person);
        4:   27:        cur = cur->next;
        -:   28:    }
        2:   29:}
        -:   30:
        9:   31:DLinkedList::DLinkedList()
        9:   32:    : head_(nullptr)
        9:   33:    , tail_(nullptr)
        9:   34:    , size_(0) {
        9:   35:}
        -:   36:
        1:   37:DLinkedList::DLinkedList(const DLinkedList& other)
        1:   38:    : head_(nullptr)
        1:   39:    , tail_(nullptr)
        1:   40:    , size_(0) {
        1:   41:    copy_from(other);
        1:   42:}
        -:   43:
        1:   44:DLinkedList::DLinkedList(DLinkedList&& other) noexcept
        1:   45:    : head_(other.head_)
        1:   46:    , tail_(other.tail_)
        1:   47:    , size_(other.size_) {
        1:   48:    other.head_ = nullptr;
        1:   49:    other.tail_ = nullptr;
        1:   50:    other.size_ = 0;
        1:   51:}
        -:   52:
        1:   53:DLinkedList& DLinkedList::operator=(const DLinkedList& other) {
        1:   54:    if (this != &other) {
        1:   55:        clear();
        1:   56:        copy_from(other);
        -:   57:    }
        1:   58:    return *this;
        -:   59:}
        -:   60:
        1:   61:DLinkedList& DLinkedList::operator=(DLinkedList&& other) noexcept {
        1:   62:    if (this != &other) {
        1:   63:        clear();
        1:   64:        head_ = other.head_;
        1:   65:        tail_ = other.tail_;
        1:   66:        size_ = other.size_;
        1:   67:        other.head_ = nullptr;
        1:   68:        other.tail_ = nullptr;
        1:   69:        other.size_ = 0;
        -:   70:    }
        1:   71:    return *this;
        -:   72:}
        -:   73:
       11:   74:DLinkedList::~DLinkedList() {
       11:   75:    clear();
       11:   76:}
        -:   77:
        -:   78:
        3:   79:bool DLinkedList::empty() const noexcept {
        3:   80:    return size_ == 0;
        -:   81:}
        -:   82:
        9:   83:std::size_t DLinkedList::size() const noexcept {
        9:   84:    return size_;
        -:   85:}
        -:   86:
        -:   87:
    #####:   88:const std::string* DLinkedList::front() const noexcept {
    #####:   89:    return head_ ? &head_->person : nullptr;
        -:   90:}
        -:   91:
        3:   92:std::string* DLinkedList::front() noexcept {
        3:   93:    return head_ ? &head_->person : nullptr;
        -:   94:}
        -:   95:
    #####:   96:const std::string* DLinkedList::back() const noexcept {
    #####:   97:    return tail_ ? &tail_->person : nullptr;
        -:   98:}
        -:   99:
        3:  100:std::string* DLinkedList::back() noexcept {
        3:  101:    return tail_ ? &tail_->person : nullptr;
        -:  102:}
        -:  103:
    #####:  104:const std::string* DLinkedList::at(std::size_t index) const {
    #####:  105:    Node* n = node_at(index);
    #####:  106:    return n ? &n->person : nullptr;
        -:  107:}
        -:  108:
        5:  109:std::string* DLinkedList::at(std::size_t index) {
        5:  110:    Node* n = node_at(index);
       5*:  111:    return n ? &n->person : nullptr;
        -:  112:}
        -:  113:
        -:  114:
        2:  115:void DLinkedList::push_front(const std::string& v) {
        2:  116:    Node* n = new_node(v, nullptr, head_);
        2:  117:    if (head_) {
        2:  118:        head_->prev = n;
        -:  119:    } else {
    #####:  120:        tail_ = n;
        -:  121:    }
        2:  122:    head_ = n;
        2:  123:    ++size_;
        2:  124:}
        -:  125:
       17:  126:void DLinkedList::push_back(const std::string& v) {
       17:  127:    Node* n = new_node(v, tail_, nullptr);
       17:  128:    if (tail_) {
        9:  129:        tail_->next = n;
        9:  130:        tail_ = n;
        -:  131:    } else {
        8:  132:        head_ = tail_ = n;
        -:  133:    }
       17:  134:    ++size_;
       17:  135:}
        -:  136:
        1:  137:bool DLinkedList::pop_front() {
       1*:  138:    if (!head_) return false;
        1:  139:    Node* t = head_;
        1:  140:    head_ = head_->next;
        1:  141:    if (head_) {
        1:  142:        head_->prev = nullptr;
        -:  143:    } else {
    #####:  144:        tail_ = nullptr;
        -:  145:    }
        1:  146:    delete t;
        1:  147:    --size_;
        1:  148:    return true;
        -:  149:}
        -:  150:
        1:  151:bool DLinkedList::pop_back() {
       1*:  152:    if (!tail_) return false;
        1:  153:    Node* t = tail_;
        1:  154:    tail_ = tail_->prev;
        1:  155:    if (tail_) {
        1:  156:        tail_->next = nullptr;
        -:  157:    } else {
    #####:  158:        head_ = nullptr;
        -:  159:    }
        1:  160:    delete t;
        1:  161:    --size_;
        1:  162:    return true;
        -:  163:}
        -:  164:
        1:  165:bool DLinkedList::insert_after(std::size_t index, const std::string& v) {
        1:  166:    Node* pos = node_at(index);
       1*:  167:    if (!pos) return false;
        1:  168:    Node* n = new_node(v, pos, pos->next);
        1:  169:    if (pos->next) {
        1:  170:        pos->next->prev = n;
        -:  171:    } else {
    #####:  172:        tail_ = n;
        -:  173:    }
        1:  174:    pos->next = n;
        1:  175:    ++size_;
        1:  176:    return true;
        -:  177:}
        -:  178:
        1:  179:bool DLinkedList::insert_before(std::size_t index, const std::string& v) {
        1:  180:    Node* pos = node_at(index);
       1*:  181:    if (!pos) return false;
        1:  182:    if (pos == head_) {
        1:  183:        push_front(v);
        1:  184:        return true;
        -:  185:    }
    #####:  186:    Node* n = new_node(v, pos->prev, pos);
    #####:  187:    pos->prev->next = n;
    #####:  188:    pos->prev = n;
    #####:  189:    ++size_;
    #####:  190:    return true;
        -:  191:}
        -:  192:
        1:  193:bool DLinkedList::erase_after(std::size_t index) {
        1:  194:    Node* pos = node_at(index);
       1*:  195:    if (!pos || !pos->next) return false;
        1:  196:    Node* t = pos->next;
        1:  197:    pos->next = t->next;
        1:  198:    if (t->next) {
        1:  199:        t->next->prev = pos;
        -:  200:    } else {
    #####:  201:        tail_ = pos;
        -:  202:    }
        1:  203:    delete t;
        1:  204:    --size_;
        1:  205:    return true;
        -:  206:}
        -:  207:
        1:  208:bool DLinkedList::erase_before(std::size_t index) {
        1:  209:    Node* pos = node_at(index);
       1*:  210:    if (!pos || !pos->prev) return false;
        1:  211:    Node* t = pos->prev;
        1:  212:    if (t->prev) {
        1:  213:        t->prev->next = pos;
        1:  214:        pos->prev = t->prev;
        -:  215:    } else {
        -:  216:        // t был головой
    #####:  217:        head_ = pos;
    #####:  218:        pos->prev = nullptr;
        -:  219:    }
        1:  220:    delete t;
        1:  221:    --size_;
        1:  222:    return true;
        -:  223:}
        -:  224:
        -:  225:
        3:  226:int DLinkedList::index_of(const std::string& x) const {
        3:  227:    int idx = 0;
        6:  228:    for (Node* cur = head_; cur; cur = cur->next, ++idx) {
        5:  229:        if (cur->person == x) return idx;
        -:  230:    }
        1:  231:    return -1;
        -:  232:}
        -:  233:
        1:  234:bool DLinkedList::erase_first(const std::string& x) {
        1:  235:    Node* cur = head_;
       1*:  236:    while (cur && cur->person != x) {
    #####:  237:        cur = cur->next;
        -:  238:    }
       1*:  239:    if (!cur) return false;
        -:  240:
       1*:  241:    if (cur->prev) cur->prev->next = cur->next;
        1:  242:    else head_ = cur->next;
        -:  243:
        1:  244:    if (cur->next) cur->next->prev = cur->prev;
    #####:  245:    else tail_ = cur->prev;
        -:  246:
        1:  247:    delete cur;
        1:  248:    --size_;
        1:  249:    return true;
        -:  250:}
        -:  251:
        1:  252:int DLinkedList::erase_all(const std::string& x) {
        1:  253:    int cnt = 0;
        1:  254:    Node* cur = head_;
        3:  255:    while (cur) {
        2:  256:        if (cur->person == x) {
        1:  257:            Node* del = cur;
        1:  258:            cur = cur->next;
        -:  259:
        1:  260:            if (del->prev) del->prev->next = del->next;
    #####:  261:            else head_ = del->next;
        -:  262:
       1*:  263:            if (del->next) del->next->prev = del->prev;
        1:  264:            else tail_ = del->prev;
        -:  265:
        1:  266:            delete del;
        1:  267:            --size_;
        1:  268:            ++cnt;
        -:  269:        } else {
        1:  270:            cur = cur->next;
        -:  271:        }
        -:  272:    }
        1:  273:    return cnt;
        -:  274:}
        -:  275:
        -:  276:
       14:  277:void DLinkedList::clear() noexcept {
       28:  278:    while (head_) {
       14:  279:        Node* t = head_;
       14:  280:        head_ = head_->next;
       14:  281:        delete t;
        -:  282:    }
       14:  283:    head_ = tail_ = nullptr;
       14:  284:    size_ = 0;
       14:  285:}
        -:  286:
        -:  287:
    #####:  288:void DLinkedList::print(std::ostream& os) const {
    #####:  289:    int i = 0;
    #####:  290:    for (Node* cur = head_; cur; cur = cur->next, ++i) {
    #####:  291:        os << i << ") " << cur->person << '\n';
        -:  292:    }
    #####:  293:}
        -:  294:
        1:  295:bool DLinkedList::save_to_file(const std::string& filename) const {
        1:  296:    std::ofstream f(filename);
       1*:  297:    if (!f.is_open()) return false;
        3:  298:    for (Node* cur = head_; cur; cur = cur->next) {
        2:  299:        f << cur->person << '\n';
        -:  300:    }
        1:  301:    return true;
        1:  302:}
        -:  303:
        1:  304:bool DLinkedList::load_from_file(const std::string& filename) {
        1:  305:    std::ifstream f(filename);
       1*:  306:    if (!f.is_open()) return false;
        1:  307:    clear();
        1:  308:    std::string s;
        3:  309:    while (std::getline(f, s)) {
        2:  310:        push_back(s);
        -:  311:    }
        1:  312:    return true;
        1:  313:}
        -:  314:
    #####:  315:bool DLinkedList::save_to_binary(const std::string& filename) const {
    #####:  316:    std::ofstream f(filename, std::ios::binary);
    #####:  317:    if (!f.is_open()) return false;
        -:  318:
    #####:  319:    f.write(reinterpret_cast<const char*>(&size_), sizeof(size_));
        -:  320:
    #####:  321:    for (Node* cur = head_; cur; cur = cur->next) {
    #####:  322:        size_t len = cur->person.size();
    #####:  323:        f.write(reinterpret_cast<const char*>(&len), sizeof(len));
    #####:  324:        f.write(cur->person.data(), len);
        -:  325:    }
    #####:  326:    return true;
    #####:  327:}
        -:  328:
    #####:  329:bool DLinkedList::load_from_binary(const std::string& filename) {
    #####:  330:    std::ifstream f(filename, std::ios::binary);
    #####:  331:    if (!f.is_open()) return false;
        -:  332:
    #####:  333:    clear();
        -:  334:
    #####:  335:    size_t count = 0;
    #####:  336:    f.read(reinterpret_cast<char*>(&count), sizeof(count));
        -:  337:
    #####:  338:    for (size_t i = 0; i < count; ++i) {
    #####:  339:        size_t len = 0;
    #####:  340:        f.read(reinterpret_cast<char*>(&len), sizeof(len));
        -:  341:        
    #####:  342:        std::string s;
    #####:  343:        s.resize(len);
    #####:  344:        f.read(&s[0], len);
        -:  345:
    #####:  346:        push_back(s);
    #####:  347:    }
    #####:  348:    return true;
    #####:  349:}
